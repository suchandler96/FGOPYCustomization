diff --git a/FGO-py/fgoAndroid.py b/FGO-py/fgoAndroid.py
index 0fcab30..ecacc16 100644
--- a/FGO-py/fgoAndroid.py
+++ b/FGO-py/fgoAndroid.py
@@ -18,7 +18,10 @@ class Android(Airtest):
             return
         try:
             super().__init__(serial,**{'cap_method':CAP_METHOD.JAVACAP}|kwargs)
-            self.package=next(i for i in re.findall(r'ACTIVITY ([A-Za-z0-9_.]+)/',self.adb.shell('dumpsys activity top'))[::-1]if(lambda x:x[2]-x[0]>959 and x[3]-x[1]>539)(self.get_render_resolution(True,i)))
+            from fgoConst import PACKAGE_TO_REGION
+            self.package=next(i for i in re.findall(r'ACTIVITY ([A-Za-z0-9_.]+)/',self.adb.shell('dumpsys activity top'))[::-1]
+                              if(lambda x, y:x[2]-x[0]>959 and x[3]-x[1]>539 and y in PACKAGE_TO_REGION.keys())
+                              (self.get_render_resolution(True,i), i))
             self.adjustOffset()
             self.rotation_watcher.reg_callback(lambda _:self.adjustOffset())
         except Exception as e:
diff --git a/FGO-py/fgoCli.py b/FGO-py/fgoCli.py
index bfc8e39..3f018a6 100644
--- a/FGO-py/fgoCli.py
+++ b/FGO-py/fgoCli.py
@@ -42,6 +42,17 @@ Some commands support <command> [<subcommand> ...] {{-h, --help}} for further in
         fgoKernel.schedule.stopOnDefeated(self.config.stopOnDefeated)
         fgoKernel.schedule.stopOnKizunaReisou(self.config.stopOnKizunaReisou)
         fgoKernel.Main.teamIndex=self.config.teamIndex
+    def get_real_class_name(self, vague_name):
+        import ast
+        with open("fgoKernel.py", "r", encoding="utf-8") as f:
+            tree = ast.parse(f.read())
+        class_names = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
+        matched_name = ""
+        for name in class_names:
+            if re.search(r"^" + vague_name, name):
+                assert matched_name == "", "the turnClass provided should not match multiple class names\n"
+                matched_name = name
+        return matched_name
     def emptyline(self):return
     def precmd(self,line):
         if line:logger.info(line)
@@ -55,7 +66,8 @@ Some commands support <command> [<subcommand> ...] {{-h, --help}} for further in
     def do_battle(self,line):
         'Finish the current battle'
         arg=parser_battle.parse_args(line.split())
-        self.work=fgoKernel.Battle()
+        real_class_name = self.get_real_class_name(arg.turnClass)
+        self.work=eval(f'lambda:fgoKernel.Battle(fgoKernel.{real_class_name})')
         self.do_continue(f'-s {arg.sleep}')
     def do_bench(self,line):
         'Benchmark'
@@ -154,7 +166,9 @@ Some commands support <command> [<subcommand> ...] {{-h, --help}} for further in
         'Loop for battle until AP empty'
         arg=parser_main.parse_args(line.split())
         fgoKernel.schedule.stopLater(arg.appoint)
-        self.work=fgoKernel.Operation(arg.quest,arg.appleCount,['gold','silver','bronze','copper','quartz'].index(arg.appleKind))
+        real_class_name = self.get_real_class_name(arg.turnClass)
+        self.work=fgoKernel.Operation(arg.quest,arg.appleCount,['gold','silver','bronze','copper','quartz'].index(arg.appleKind),
+                                      battleClass=eval("lambda:fgoKernel.Battle(fgoKernel."+real_class_name+")"))
         self.do_continue(f'-s {arg.sleep}')
     def complete_main(self,text,line,begidx,endidx):
         return self.completecommands({
@@ -261,6 +275,7 @@ class ArgStruct:
 
 parser_battle=ArgParser(prog='battle',description=Cmd.do_battle.__doc__)
 parser_battle.add_argument('-s','--sleep',help='Sleep before run (default: %(default)s)',type=validator(str,lambda x:re.match(r'\d+([:.]\d+)*$',x),'timedelta'),default='0')
+parser_battle.add_argument('-t','--turnClass',type=str,default="Turn")
 
 parser_bench=ArgParser(prog='bench',description=Cmd.do_bench.__doc__)
 parser_bench.add_argument('-n','--number',help='Number of runs (default: %(default)s)',type=validator(int,lambda x:x>=3,'not-less-than-3 int'),default=20)
@@ -285,6 +300,7 @@ parser_main.add_argument('appleKind',help='Apple Kind (default: %(default)s)',ty
 parser_main.add_argument('-s','--sleep',help='Sleep before run (default: %(default)s)',type=validator(str,lambda x:re.match(r'\d+([:.]\d+)*$',x),'timedelta'),default='0')
 parser_main.add_argument('-a','--appoint',help='Battle count limit (default: %(default)s for no limit)',type=validator(int,lambda x:x>=0,'nonnegative int'),default=0)
 parser_main.add_argument('-q','--quest',help='Goto different quests for different times',action='append',type=ArgStruct(lambda x:tuple(int(i)for i in x.split('-')),validator(int,lambda x:x>=0,'nonnegative int')),default=[],nargs=2)
+parser_main.add_argument('-t','--turnClass',type=str,default="Turn")
 
 parser_press=ArgParser(prog='press',description=Cmd.do_press.__doc__)
 parser_press.add_argument('button',help='Button',type=str.upper)
diff --git a/FGO-py/fgoDetect.py b/FGO-py/fgoDetect.py
index 3335559..2efca75 100644
--- a/FGO-py/fgoDetect.py
+++ b/FGO-py/fgoDetect.py
@@ -45,6 +45,9 @@ class XDetectBase(metaclass=logMeta(logger)):
                 try:return func(self,*args,**kwargs)
                 except err:pass
                 logger.warning(f'Retry {getattr(func,"__qualname__",func)}({",".join(repr(i)for i in args)}{","if kwargs else""}{",".join("%s=%r"%i for i in kwargs.items())})')
+                if getattr(func,"__qualname__",func) == "XDetectBase.getCardColor":
+                    import fgoDevice
+                    fgoDevice.device.perform(' ',(2100,))
                 return wrap(type(self)(),*args,**kwargs)
             return wrap
         return wrapper
@@ -165,6 +168,43 @@ class XDetectBase(metaclass=logMeta(logger)):
     @retryOnError()
     @validate()
     def getStageTotal(self):return self._ocrInt((912,13,932,38))
+    def getAP(self):
+        # find the position of slash
+        slash_center_coord = self._find(self.tmpl.SLASH, (656,363,800,432), .2)
+
+        curr_ap_line_top = slash_center_coord[1] - (self.tmpl.SLASH[0].shape[0]>>1)
+        curr_ap_line_btm = slash_center_coord[1] + (self.tmpl.SLASH[0].shape[0]>>1)
+        slash_left = slash_center_coord[0] - (self.tmpl.SLASH[0].shape[1]>>1)
+        slash_right = slash_center_coord[0] + (self.tmpl.SLASH[0].shape[1]>>1)
+
+        ap_to_consume = self._ocrInt((728,curr_ap_line_top-36,800,curr_ap_line_top))
+        ap_enough = True
+        for i in range(curr_ap_line_top-36, curr_ap_line_top):
+            for j in range(728, 800):
+                if self.im[i, j, 0] < 10 and self.im[i, j, 1] < 10 and self.im[i, j, 2] > 200:
+                    ap_enough = False   # if any pixel is red, then AP is not enough
+                    break
+        print("ap_enough:", ap_enough)
+
+        cur_ap_im = self._crop((656,curr_ap_line_top,slash_left,curr_ap_line_btm))
+        blank = numpy.zeros(cur_ap_im.shape, cur_ap_im.dtype)
+        dst = numpy.clip(cv2.addWeighted(cur_ap_im, 0.5, blank, 1-0.5, 150), 0, 255).astype(numpy.uint8)
+        dst = cv2.cvtColor(dst, cv2.COLOR_BGR2HSV)
+        for i in range(dst.shape[0]):
+            for j in range(dst.shape[1]):
+                if dst[i, j, 2] > 200:
+                    dst[i, j, 2] = 255
+
+        dst = cv2.cvtColor(dst, cv2.COLOR_HSV2BGR)
+        ap_current = OCR.EN.ocrInt(dst)
+
+        if not ap_enough and ap_current >= ap_to_consume:
+            print("ap_current =", ap_current, ", ap_to_consume =", ap_to_consume)
+            print("potential error in OCR, setting ap_current to 0")
+            ap_current = 0
+
+        ap_full = self._ocrInt((slash_right,curr_ap_line_top,800,curr_ap_line_btm))
+        return ap_to_consume, ap_current, ap_full
     def getSummonHistory(self):XDetectBase._summonHistory=self._stack(XDetectBase._summonHistory,cv2.threshold(cv2.cvtColor(self._crop((147,157,1105,547)),cv2.COLOR_BGR2GRAY),128,255,cv2.THRESH_BINARY)[1],80)
     @classmethod
     def getSummonHistoryCount(cls):return cls.__new__(cls).inject(XDetectBase._summonHistory)._count((cls.tmpl.SUMMONHISTORY[0][...,0],cls.tmpl.SUMMONHISTORY[1]),(28,0,60,XDetectBase._summonHistory.shape[0]),.7)
@@ -193,6 +233,56 @@ class XDetectBase(metaclass=logMeta(logger)):
 class XDetectCN(XDetectBase):
     tmpl=IMG_CN
     ocr=OCR.ZHS
+    def getAP(self):
+        # import datetime
+        # time_stamp = str(datetime.datetime.now())
+        # try:
+        #     print(time_stamp, "save figure")
+        #     self.save()
+        # except:
+        #     print(time_stamp, "save figure failed")
+        #     pass
+
+        # find the position of slash
+        slash_center_coord = self._find(self.tmpl.SLASH, (662,328,800,365), .2)
+        # originally, (662,328,800,365) -> (656,363,800,432)
+
+        curr_ap_line_top = slash_center_coord[1] - (self.tmpl.SLASH[0].shape[0]>>1)
+        curr_ap_line_btm = slash_center_coord[1] + (self.tmpl.SLASH[0].shape[0]>>1)
+        slash_left = slash_center_coord[0] - (self.tmpl.SLASH[0].shape[1]>>1)
+        slash_right = slash_center_coord[0] + (self.tmpl.SLASH[0].shape[1]>>1)
+        # self.save(name="ocr_ap_to_consume", rect=(662,curr_ap_line_top-36,800,curr_ap_line_top))
+        ap_to_consume = self._ocrInt((662,curr_ap_line_top-36,800,curr_ap_line_top))    # originally, 662 -> 728
+        ap_enough = True
+        for i in range(curr_ap_line_top-36, curr_ap_line_top):
+            for j in range(662, 800):
+                if self.im[i, j, 0] < 10 and self.im[i, j, 1] < 10 and self.im[i, j, 2] > 200:
+                    ap_enough = False   # if any pixel is red, then AP is not enough
+                    break
+        print("ap_enough:", ap_enough)
+
+        # self.save(name="ocr_ap_current", rect=(662,curr_ap_line_top,slash_left,curr_ap_line_btm))
+        cur_ap_im = self._crop((662,curr_ap_line_top,slash_left,curr_ap_line_btm))  # originally, 662 -> 656
+        blank = numpy.zeros(cur_ap_im.shape, cur_ap_im.dtype)
+        dst = numpy.clip(cv2.addWeighted(cur_ap_im, 0.5, blank, 1-0.5, 150), 0, 255).astype(numpy.uint8)
+        dst = cv2.cvtColor(dst, cv2.COLOR_BGR2HSV)
+        for i in range(dst.shape[0]):
+            for j in range(dst.shape[1]):
+                if dst[i, j, 2] > 200:
+                    dst[i, j, 2] = 255
+
+        dst = cv2.cvtColor(dst, cv2.COLOR_HSV2BGR)
+        ap_current = OCR.EN.ocrInt(dst)
+        # cv2.imwrite(time.strftime(f'processed_ocr_ap_current{f"_%Y-%m-%d_%H.%M.%S.{round(self.time*1000)%1000:03}"}.png',time.localtime(self.time)),dst,[cv2.IMWRITE_PNG_COMPRESSION,9])
+
+        if not ap_enough and ap_current >= ap_to_consume:
+            print("ap_current =", ap_current, ", ap_to_consume =", ap_to_consume)
+            print("potential error in OCR, setting ap_current to 0")
+            ap_current = 0
+
+        # self.save(name="ocr_ap_full", rect=(slash_right,curr_ap_line_top,800,curr_ap_line_btm))
+        ap_full = self._ocrInt((slash_right,curr_ap_line_top,800,curr_ap_line_btm))
+        return ap_to_consume, ap_current, ap_full
     @classmethod
     def saveWeeklyMission(cls):
         result=[]
@@ -219,7 +309,7 @@ class DetectBase(XDetectBase):
     def __init__(self,anteLatency=.1,postLatency=0):
         schedule.sleep(anteLatency)
         super().__init__()
-        fuse.increase()
+        fuse.increase(self)
         schedule.sleep(postLatency)
     def _compare(self,*args,**kwargs):return super()._compare(*args,**kwargs)and fuse.reset(self)
     def _find(self,*args,**kwargs):
diff --git a/FGO-py/fgoFuse.py b/FGO-py/fgoFuse.py
index 9e67142..38195b1 100644
--- a/FGO-py/fgoFuse.py
+++ b/FGO-py/fgoFuse.py
@@ -1,6 +1,11 @@
+import time
+
 from fgoLogging import getLogger
 from fgoSchedule import ScriptStop
 logger=getLogger('Fuse')
+import fgoDevice
+import traceback
+import datetime
 
 class Fuse:
     def __init__(self,fv=300,logsize=10):
@@ -9,14 +14,54 @@ class Fuse:
         self.logsize=logsize
         self.log=[None]*logsize
         self.logptr=0
-    def increase(self):
+        self.tried_press = False
+        self.tried_handle = False
+    def increase(self, detect=None):
         logger.debug(f'{self.value}')
         if self.value>self.max:
-            self.save()
-            raise ScriptStop('Fused')
+            if self.tried_press and self.tried_handle and self.value>self.max+10:
+                detect.save(name="FuseFinal")
+                traceback.print_stack()
+                raise ScriptStop('Fused')
+            elif not self.tried_press:
+                self.tried_press = True
+                detect.save(name="FuseBeforePress_0")
+                print(datetime.datetime.now(), "try to avoid fuse with key press")
+                fgoDevice.device.perform('\x08',(5100,))
+                fgoDevice.device.perform('K',(5000,))
+                fgoDevice.device.perform('J',(5000,))
+                time.sleep(120)
+                for i in range(1, 7):
+                    detect.save(name="FuseBeforePress_"+str(i))
+                    fgoDevice.device.perform('K',(1000,))
+                    time.sleep(60)
+            elif self.tried_press and not self.tried_handle:
+                self.tried_handle = True
+                detect.save(name="FuseBeforeHandle_0")
+                print(datetime.datetime.now(), "try to avoid fuse with key handle")
+                fgoDevice.device.perform('\x08',(5100,))
+                fgoDevice.device.perform('K',(5000,))
+                fgoDevice.device.perform('J',(5000,))
+                time.sleep(120)
+                for i in range(1, 7):
+                    detect.save(name="FuseBeforeHandle_"+str(i))
+                    fgoDevice.device.perform('K',(1000,))
+                    time.sleep(60)
+                # if Detect(.5, .5).isBattleContinue():
+                #     fgoDevice.device.press('K')
+                # elif Detect.cache.isChooseFriend():
+                #     if Detect.cache.isNoFriend():
+                #         fgoDevice.device.perform('\xBAK',(500,1000))
+                #     else:
+                #         fgoDevice.device.touch((640,200))   # select first friend
+                # elif Detect.cache.isSkillCastFailed():
+                #     fgoDevice.device.press('J')
+
         self.value+=1
     def reset(self,detect=None):
         self.value=0
+        self.tried_press = False
+        self.tried_handle = False
         if detect is not None and detect is not self.log[(self.logptr-1)%self.logsize]:
             self.log[self.logptr]=detect
             self.logptr=(self.logptr+1)%self.logsize
diff --git a/FGO-py/fgoImageListener.py b/FGO-py/fgoImageListener.py
index 234771d..a39059d 100644
--- a/FGO-py/fgoImageListener.py
+++ b/FGO-py/fgoImageListener.py
@@ -70,7 +70,7 @@ else:
         def get(self):return[]
 class ImageListener(dict):
     def __init__(self,path,ends='.png'):
-        super().__init__((file[:-len(ends)],(lambda x:(x,numpy.max(x,axis=2)>>1))(cv2.imread(path+file)))for file in os.listdir(path)if file.endswith(ends))
+        super().__init__((file[:-len(ends)],(lambda x:(x,numpy.max(x,axis=2)>>1))(cv2.imread(path+file)))for file in sorted(os.listdir(path))if file.endswith(ends))
         self.path=path
         self.ends=ends
         self.listener=DirListener(path)
diff --git a/FGO-py/fgoKernel.py b/FGO-py/fgoKernel.py
index 368b46f..ddec6f8 100644
--- a/FGO-py/fgoKernel.py
+++ b/FGO-py/fgoKernel.py
@@ -17,10 +17,12 @@
 # .  Grand Order/Anima Animusphere
 # .     冠位指定/人理保障天球
 'Full-automatic FGO Script'
+import traceback
+
 from fgoConst import VERSION
 __version__=VERSION
 __author__='hgjazhgj'
-import logging,numpy,pulp,random,re,time,threading
+import cv2,logging,numpy,pulp,random,re,time,threading,datetime
 import fgoDevice
 from itertools import permutations
 from functools import wraps
@@ -408,6 +410,250 @@ class Turn:
         if t:=Detect(.4).getSkillTargetCount():fgoDevice.device.perform(['3333','2244','3234'][t-1][target],(300,))
         while not Detect().isTurnBegin():pass
         Detect(.5)
+
+
+class CustomTurn:
+    def __init__(self):
+        self.stage=0
+        self.stageTurn=0
+        self.countDown=[[[0,0,0],[0,0,0],[0,0,0]],[0,0,0]]
+    def __call__(self,turn):
+        self.stage,self.stageTurn=[t:=Detect(.2).getStage(),1+self.stageTurn*(self.stage==t)]
+        if turn==1:
+            Detect.cache.setupServantDead()
+            self.stageTotal=Detect.cache.getStageTotal()
+            self.servant=[(lambda x:(x,)+servantData.get(x,(0,0,0,0,(0,0),((0,0),(0,0),(0,0)))))(Detect.cache.getFieldServant(i))for i in range(3)]
+        else:
+            for i in(i for i in range(3)if Detect.cache.isServantDead(i)):
+                self.servant[i]=(lambda x:(x,)+servantData.get(x,(0,0,0,0,(0,0),((0,0),(0,0),(0,0)))))(Detect.cache.getFieldServant(i))
+                self.countDown[0][i]=[0,0,0]
+        logger.info(f'Turn {turn} Stage {self.stage} StageTurn {self.stageTurn} {[i[0]for i in self.servant]}')
+        if self.stageTurn==1:Detect.cache.setupEnemyGird()
+        self.enemy=[Detect.cache.getEnemyHp(i)for i in range(6)]
+        self.dispatchSkill()
+        fgoDevice.device.perform(' ',(2100,))
+        fgoDevice.device.perform(self.selectCard(),(300,300,2300,1300,6000))
+    def dispatchSkill(self):
+        self.countDown=[[[max(0,j-1)for j in i]for i in self.countDown[0]],[max(0,i-1)for i in self.countDown[1]]]
+        while skill:=[(0,i,j)for i in range(3)for j in range(3)if not self.countDown[0][i][j]and self.servant[i][0]and self.servant[i][6][j][0]and Detect.cache.isSkillReady(i,j)]: # +[(1,i)for i in range(3)if self.countDown[1][i]==0]:
+            for i in skill:
+                if i[0]==0:
+                    match self.servant[i[1]][6][i[2]]:
+                        case 1,_:
+                            self.castServantSkill(i[1],i[2],i[1]+1)
+                            continue
+                        case 2,p:
+                            np=[Detect.cache.getFieldServantNp(i)if self.servant[i][0]else 100 for i in range(3)]
+                            match p:
+                                case 0:
+                                    if any(i<100 for i in np):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 1:
+                                    target=numpy.argmin(np)
+                                    if np[target]<100:
+                                        self.castServantSkill(i[1],i[2],target+1)
+                                        continue
+                                case 2:
+                                    np[i[1]]=100
+                                    if any(i<100 for i in np):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 3|4:
+                                    if self.stageTurn>1:
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 5:
+                                    if np[i[1]]<100:
+                                        self.castServantSkill(i[1],i[2],i[1]+1)
+                                        continue
+                                case _:
+                                    self.castServantSkill(i[1],i[2],0)
+                                    continue
+                        case 3,p:
+                            np=[Detect.cache.getFieldServantNp(i)if self.servant[i][0]else 0 for i in range(3)]
+                            match p:
+                                case 0|3|4:
+                                    if any(i>=100 for i in np):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 1:
+                                    target=numpy.argmax(np)
+                                    if np[target]>=100:
+                                        self.castServantSkill(i[1],i[2],target+1)
+                                        continue
+                                case 2:
+                                    np[i[1]]=0
+                                    if any(i>=100 for i in np):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 5:
+                                    if np[i[1]]>=100:
+                                        self.castServantSkill(i[1],i[2],i[1]+1)
+                                        continue
+                                case _:
+                                    self.castServantSkill(i[1],i[2],0)
+                                    continue
+                        case 4|5|6,_:
+                            self.castServantSkill(i[1],i[2],0)
+                            continue
+                        case 7,p:
+                            hp=[Detect.cache.getFieldServantHp(i)if self.servant[i][0]else 999999 for i in range(3)]
+                            match p:
+                                case 0:
+                                    if any(i<6600 for i in hp):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 1:
+                                    target=numpy.argmin(hp)
+                                    if hp[target]<6600:
+                                        self.castServantSkill(i[1],i[2],target+1)
+                                        continue
+                                case 2:
+                                    hp[i[1]]=999999
+                                    if any(i<6600 for i in hp):
+                                        self.castServantSkill(i[1],i[2],0)
+                                        continue
+                                case 3|4:
+                                    self.castServantSkill(i[1],i[2],0)
+                                    continue
+                                case 5:
+                                    if hp[i[1]]<6600:
+                                        self.castServantSkill(i[1],i[2],i[1]+1)
+                                        continue
+                                case _:
+                                    self.castServantSkill(i[1],i[2],0)
+                                    continue
+                        case 8,_:
+                            if any((lambda x:x[1]and x[0]==x[1])(Detect.cache.getEnemyNp(i))for i in range(6)):
+                                self.castServantSkill(i[1],i[2],i[1]+1)
+                                continue
+                        case 9,_:
+                            if any((lambda x:x[1]and x[0]==x[1])(Detect.cache.getEnemyNp(i))for i in range(6))or Detect.cache.getFieldServantHp(i[1])<3300:
+                                self.castServantSkill(i[1],i[2],i[1]+1)
+                                continue
+                    self.countDown[0][i[1]][i[2]]=1
+                else:...
+    @logit(logger,logging.INFO)
+    def selectCard(self):
+        color,sealed,hougu,np,resist,critical,group=Detect().getCardColor()+[i[5][1]for i in self.servant],Detect.cache.isCardSealed(),Detect.cache.isHouguReady(),[Detect.cache.getFieldServantNp(i)<100 for i in range(3)],[[1,1.7,.6][i]for i in Detect.cache.getCardResist()],[i/10 for i in Detect.cache.getCardCriticalRate()],[next(j for j,k in enumerate(self.servant)if k[0]==i)for i in Detect.cache.getCardServant([i[0] for i in self.servant if i[0]])]+[0,1,2]
+        houguTargeted,houguArea,houguSupport=[[j for j in range(3)if hougu[j]and self.servant[j][0]and self.servant[j][5][0]==i]for i in range(3)]
+        houguArea=houguArea if self.stage==self.stageTotal or sum(i>0 for i in self.enemy)>1 and sum(self.enemy)>12000 else[]
+        houguTargeted=houguTargeted if self.stage==self.stageTotal or max(self.enemy)>23000+8000*len(houguArea)else[]
+        hougu=[i+5 for i in houguSupport+houguArea+houguTargeted]
+        if self.stageTurn==1 or houguTargeted or self.enemy[self.target]==0:
+            self.target=numpy.argmax(self.enemy)
+            fgoDevice.device.perform('\x67\x68\x69\x64\x65\x66'[self.target],(500,))
+        self.enemy=[max(0,i-18000*len(houguArea))for i in self.enemy]
+        if any(self.enemy)and self.enemy[self.target]==0:self.target=next(i for i in range(5,-1,-1)if self.enemy[i])
+        for _ in houguTargeted:
+            self.enemy[self.target]=max(0,self.enemy[self.target]-48000)
+            if any(self.enemy)and self.enemy[self.target]==0:self.target=next(i for i in range(5,-1,-1)if self.enemy[i])
+        def evaluate(card):return(lambda chainError:(lambda colorChain:(lambda firstBonus:
+            sum(
+                ((.3*bool(firstBonus&4)+.1*bool(firstBonus&1)+[1.,1.2,1.4][i]*[1,.8,1.1][color[j]])*(1+min(1,critical[j]+.2*bool(firstBonus&2)))+bool(colorChain==2))*resist[j]*(not sealed[j])
+                for i,j in enumerate(card)if j<5
+            )
+            +4*(len([i for i in self.enemy if i])>1)*(self.enemy[self.target]<20000)*sum(bool(i)for i in numpy.diff([group[i]for i in card if i<5]))
+            +(1.8 if colorChain==-1 else 3)*(not chainError and len({group[i]for i in card})==1)*resist[card[0]]
+            +2.3*(colorChain==0)*len({group[i]for i in card if i<5 and np[group[i]]})
+            +3*(colorChain==1)
+            )(7 if colorChain==3 else 1<<color[0]))(-1 if chainError else{(0,):0,(1):1,(2,):2,(0,1,2):3}.get(tuple(set(color[i]for i in card)),-1)))(any(sealed[i]for i in card if i<5))
+        card=list(max(permutations(range(5),3-len(hougu)),key=lambda x:evaluate(hougu+list(x))))
+        return''.join(['12345678'[i]for i in hougu+card+list({0,1,2,3,4}-set(card))])
+    @logit(logger,logging.INFO)
+    def selectCard_for_np(self, servant_id):
+        color,sealed,hougu,np,resist,critical,group=Detect().getCardColor()+[i[5][1]for i in self.servant],Detect.cache.isCardSealed(),Detect.cache.isHouguReady(),[Detect.cache.getFieldServantNp(i)<100 for i in range(3)],[[1,1.7,.6][i]for i in Detect.cache.getCardResist()],[i/10 for i in Detect.cache.getCardCriticalRate()],[next(j for j,k in enumerate(self.servant)if k[0]==i)for i in Detect.cache.getCardServant([i[0] for i in self.servant if i[0]])]+[0,1,2]
+        houguTargeted,houguArea,houguSupport=[[j for j in range(3)if hougu[j]and self.servant[j][0]and self.servant[j][5][0]==i]for i in range(3)]
+        houguArea=houguArea if self.stage==self.stageTotal or sum(i>0 for i in self.enemy)>1 and sum(self.enemy)>12000 else[]
+        houguTargeted=houguTargeted if self.stage==self.stageTotal or max(self.enemy)>23000+8000*len(houguArea)else[]
+        hougu=[i+5 for i in houguSupport+houguArea+houguTargeted]
+        if self.stageTurn==1 or houguTargeted or self.enemy[self.target]==0:
+            self.target=numpy.argmax(self.enemy)
+            fgoDevice.device.perform('\x67\x68\x69\x64\x65\x66'[self.target],(500,))
+        self.enemy=[max(0,i-18000*len(houguArea))for i in self.enemy]
+        if any(self.enemy)and self.enemy[self.target]==0:self.target=next(i for i in range(5,-1,-1)if self.enemy[i])
+        for _ in houguTargeted:
+            self.enemy[self.target]=max(0,self.enemy[self.target]-48000)
+            if any(self.enemy)and self.enemy[self.target]==0:self.target=next(i for i in range(5,-1,-1)if self.enemy[i])
+        def evaluate(card):
+            mark = 0
+            for i in range(3):
+                if group[card[i]] == servant_id:
+                    if color[card[i]] == 0:
+                        mark += (30 + i)
+                    elif color[card[i]] == 1:
+                        mark += (10 + i)
+
+            if color[card[0]] == color[card[1]] == color[card[2]] == 0 and servant_id in [group[card[0]], group[card[1]], group[card[2]]]:
+                mark += 100
+            return mark
+        card=list(max(permutations(range(5),3),key=lambda x:evaluate(list(x))))
+        return''.join(['12345678'[i]for i in card+list({0,1,2,3,4}-set(card))])
+    def castServantSkill(self,pos,skill,target):
+        fgoDevice.device.press(('ASD','FGH','JKL')[pos][skill])
+        if Detect(.7).isSkillNone():
+            logger.warning(f'Skill {pos} {skill} Disabled')
+            self.countDown[0][pos][skill]=999
+            fgoDevice.device.press('\x08')
+        elif Detect.cache.isSkillCastFailed():
+            logger.warning(f'Skill {pos} {skill} Cast Failed')
+            self.countDown[0][pos][skill]=1
+            fgoDevice.device.press('J')
+        elif t:=Detect.cache.getSkillTargetCount():fgoDevice.device.perform(['3333','2244','3234'][t-1][f-5 if(f:=self.servant[pos][6][skill][1])in{6,7,8}else target]+'\x08',(300,700))
+        else:fgoDevice.device.perform('\x08',(700,))
+        while not Detect().isTurnBegin():pass
+        Detect(.5)
+
+    def castSingleOrNoTargetServantSkill(self,pos,skill,target):
+        fgoDevice.device.press(('ASD','FGH','JKL')[pos][skill])
+        if Detect(.7).isSkillNone():
+            logger.warning(f'Skill {pos} {skill} Disabled')
+            self.countDown[0][pos][skill]=999
+            fgoDevice.device.press('\x08')
+        elif Detect.cache.isSkillCastFailed():
+            logger.warning(f'Skill {pos} {skill} Cast Failed')
+            self.countDown[0][pos][skill]=1
+            fgoDevice.device.press('J')
+        elif t:=Detect.cache.getSkillTargetCount():
+            fgoDevice.device.perform('234'[target]+'\x08',(300,700))
+        else:
+            fgoDevice.device.perform('\x08',(700,))
+        while not Detect().isTurnBegin():pass
+        Detect(.5)
+
+    # targets expect a list, even when the master skill applies to a single servant
+    # do not consider master skills that apply to enemies currently
+    def castMasterSkill(self, skill, targets=[0, 3]):
+        self.countDown[1][skill]=15
+        # fgoDevice.device.perform('Q'+'WER'[skill],(300,300))
+        fgoDevice.device.perform('Q'+'WER'[skill],(600,300))
+        if Detect(.7).isSkillNone():
+            fgoDevice.device.perform('\x08',(700,))
+        else:
+            try:
+                if len(targets) == 2:   # exchange servants
+                    fgoDevice.device.perform(('TYUIOP'[targets[0]],'TYUIOP'[targets[1]],'Z'),(300,300,2600))
+                    fgoDevice.device.perform('\x08',(2300,))
+                    while not Detect().isTurnBegin():pass
+                elif len(targets) == 1:
+                    if targets[0] >= 3:
+                        print("Invalid target when casting master skill, skip")
+                        return
+                    fgoDevice.device.perform('234'[targets[0]],(300,))
+            except:
+                if isinstance(targets, int):    # view as single target skill
+                    if targets >= 3:
+                        print("Invalid target when casting master skill, skip")
+                        return
+                    fgoDevice.device.perform('234'[targets],(300,))
+
+        while not Detect().isTurnBegin():pass
+        Detect(.5)
+    def getNP(self): return [Detect.cache.getFieldServantNp(i) for i in range(3)]
+    def getServantHP(self): return [Detect.cache.getFieldServantHp(i)if self.servant[i][0]else 999999 for i in range(3)]
+
+
 class Battle:
     def __init__(self,turnClass=Turn):
         self.turn=0
@@ -479,6 +725,20 @@ class Main:
                     if self.battleCount==battleTotal:
                         fgoDevice.device.press('F')
                         return logger.info('Operation Unit Completed')
+                    wait_for_ap = True      # before confirm to continue, check AP
+                    if wait_for_ap:
+                        try:
+                            ap_to_consume, ap_current, ap_full = Detect(.7,.3).getAP()
+                            print(datetime.datetime.now(), "AP to consume:", ap_to_consume, "current AP:", ap_current, "full AP:", ap_full)
+                            if not self.appleTotal and ap_current < ap_to_consume:
+                                print("plan to sleep for", (ap_to_consume-ap_current)*5, "minutes")
+                                for time_consumed in range(0, (ap_to_consume-ap_current)*5*60, 60):
+                                    print(datetime.datetime.now(), "ready to sleep")
+                                    fgoDevice.device.perform('\xBB',(2100,))
+                                    time.sleep(60)
+                        except:
+                            print("error in getAP(), continue directly")
+                            traceback.print_exc()
                     fgoDevice.device.press('K')
                     if Detect(.7,.3).isApEmpty()and not self.eatApple():return logger.info('Ap Empty')
                     self.chooseFriend()
@@ -536,7 +796,7 @@ class Main:
                 fgoDevice.device.perform('\xBAK',(500,1000))
                 refresh=True
                 continue
-            if Detect.cache.isBattleFormation():return
+            if Detect.cache.isBattleFormation() or Detect.cache.isTurnBegin():return
         if not friendImg.flush():return fgoDevice.device.press('8')
         while True:
             timer=time.time()
@@ -553,7 +813,9 @@ class Main:
             if refresh:schedule.sleep(max(0,timer+10-time.time()))
             fgoDevice.device.perform('\xBAK',(500,1000))
             refresh=True
-            while not Detect(.2).isChooseFriend():
+            while not (Detect(.2).isChooseFriend() and not Detect.cache.isBattleContinue()):
+                # wait until the confirm refresh dialog box disappears
+                # The button to confirm refresh is at the same position as continue battle
                 if Detect.cache.isNoFriend():
                     schedule.sleep(10)
                     fgoDevice.device.perform('\xBAK',(500,1000))
